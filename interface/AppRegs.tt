<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ parameter name="RegisterMetadataPath" type="string" #>
<#@ parameter name="IOMetadataPath" type="string" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Firmware.tt" #><##>
<#@ output extension=".h" #>
#ifndef _APP_IOS_AND_REGS_H_
#define _APP_IOS_AND_REGS_H_
#include "cpu.h"
<#
var deviceMetadata = TemplateHelper.ReadDeviceMetadata(RegisterMetadataPath);
var portPinMetadata = TemplateHelper.ReadPortPinMetadata(IOMetadataPath);
var inputPins = TemplateHelper.GetPortPinsOfType<InputPinInfo>(portPinMetadata).ToList();
var outputPins = TemplateHelper.GetPortPinsOfType<OutputPinInfo>(portPinMetadata).ToList();
var deviceName = deviceMetadata.Device;

int maxRegisterNameLength = 0;
int minRegisterAddress = byte.MaxValue;
int maxRegisterAddress = 32;
int totalRegisterSize = 0;
foreach (var registerMetadata in deviceMetadata.Registers)
{
    var register = registerMetadata.Value;
    var registerName = FirmwareNamingConvention.Instance.Apply(registerMetadata.Key);
    maxRegisterNameLength = Math.Max(maxRegisterNameLength, registerName.Length);
    minRegisterAddress = Math.Min(minRegisterAddress, register.Address);
    maxRegisterAddress = Math.Max(maxRegisterAddress, register.Address);
    totalRegisterSize += Math.Max(1, register.Length) * TemplateHelper.GetPayloadTypeSize(register.Type);
}
#>

void init_ios(void);
<#
var maxPinNameLength = Math.Max(
    inputPins.Count > 0 ? inputPins.Max(pin => FirmwareNamingConvention.Instance.Apply(pin.Key).Length) : 0,
    outputPins.Count > 0 ? outputPins.Max(pin => FirmwareNamingConvention.Instance.Apply(pin.Key).Length) : 0);
if (inputPins.Count > 0)
{
#>
/************************************************************************/
/* Definition of input pins                                             */
/************************************************************************/
<#
    foreach (var pin in inputPins)
    {
        var pinName = FirmwareNamingConvention.Instance.Apply(pin.Key);
        var descriptionOffset = maxPinNameLength - pinName.Length + 10;
#>
// <#= pinName #><#= new string(' ', descriptionOffset) #>Description: <#= pin.Value.Description #>
<#
    }
#>

<#
    foreach (var pin in inputPins)
    {
        var pinInfo = pin.Value;
        var pinName = FirmwareNamingConvention.Instance.Apply(pin.Key);
        var nameOffset = maxPinNameLength - pinName.Length + 4;
#>
#define read_<#= pinName #> read_io(<#= pinInfo.Port #>, <#= pinInfo.PinNumber #>)<#= new string(' ', nameOffset) #>// <#= pinName #>
<#
    }
#>

<#
}
#>
<#
if (outputPins.Count > 0)
{
#>
/************************************************************************/
/* Definition of output pins                                            */
/************************************************************************/
<#
    foreach (var pin in outputPins)
    {
        var pinName = FirmwareNamingConvention.Instance.Apply(pin.Key);
        var descriptionOffset = maxPinNameLength - pinName.Length + 10;
#>
// <#= pinName #><#= new string(' ', descriptionOffset) #>Description: <#= pin.Value.Description #>
<#
    }
#>
<#
    foreach (var pin in outputPins)
    {
        var pinInfo = pin.Value;
        var pinName = FirmwareNamingConvention.Instance.Apply(pin.Key);
        var setFunc = pinInfo.Invert ? "clear_io" : "set_io";
        var clrFunc = pinInfo.Invert ? "set_io" : "clear_io";
#>

/* <#= pinName #> */
#define set_<#= pinName #> <#= setFunc #>(<#= pinInfo.Port #>, <#= pinInfo.PinNumber #>)
#define clr_<#= pinName #> <#= clrFunc #>(<#= pinInfo.Port #>, <#= pinInfo.PinNumber #>)
#define tgl_<#= pinName #> toggle_io(<#= pinInfo.Port #>, <#= pinInfo.PinNumber #>)
#define read_<#= pinName #> read_io(<#= pinInfo.Port #>, <#= pinInfo.PinNumber #>)
<#
    }
#>

<#
}
#>
/************************************************************************/
/* Registers' structure                                                 */
/************************************************************************/
typedef struct
{
<#
foreach (var registerMetadata in deviceMetadata.Registers)
{
    var register = registerMetadata.Value;
    var registerName = FirmwareNamingConvention.Instance.Apply(registerMetadata.Key);
    var arrayType = register.Length > 0 ? $"[{register.Length}]" : string.Empty;
    var firmwareType = TemplateHelper.GetFirmwareType(register.Type);
#>
    <#= firmwareType #> REG_<#= registerName #><#= arrayType #>;
<#
}
#>
} AppRegs;

/************************************************************************/
/* Registers' address                                                   */
/************************************************************************/
/* Registers */
<#
foreach (var registerMetadata in deviceMetadata.Registers)
{
    var register = registerMetadata.Value;
    var registerName = FirmwareNamingConvention.Instance.Apply(registerMetadata.Key);
    var addressOffset = new string(' ', maxRegisterNameLength - registerName.Length + 4);
    var descriptionOffset = new string(' ', 7 - register.Type.ToString().Length);
#>
#define ADD_REG_<#= registerName #><#= addressOffset #><#= register.Address #> // <#= register.Type #><#= descriptionOffset #><#= register.Description #>
<#
}
#>

/************************************************************************/
/* <#= deviceName #> registers' memory limits<#= new string(' ', 44 - deviceName.Length) #>*/
/*                                                                      */
/* DON'T change the APP_REGS_ADD_MIN value !!!                          */
/* DON'T change these names !!!                                         */
/************************************************************************/
/* Memory limits */
#define APP_REGS_ADD_MIN                    0x<#= minRegisterAddress.ToString("X") #>
#define APP_REGS_ADD_MAX                    0x<#= maxRegisterAddress.ToString("X") #>
#define APP_NBYTES_OF_REG_BANK              <#= totalRegisterSize #>

/************************************************************************/
/* Registers' bits                                                      */
/************************************************************************/
<#
var maxBitNameLength = deviceMetadata.BitMasks.Values
    .SelectMany(mask => mask.Bits)
    .Select(bitField => FirmwareNamingConvention.Instance.Apply(bitField.Key).Length)
    .Prepend(0).Max();
var maxMemberNameLength = (from groupMask in deviceMetadata.GroupMasks
                           let maskName = FirmwareGroupMaskNamingConvention.Instance.Apply(groupMask.Key)
                           from member in groupMask.Value.Values
                           let memberName = FirmwareNamingConvention.Instance.Apply(member.Key)
                           select maskName.Length + memberName.Length)
                           .Prepend(0).Max();
var maxBitMemberNameLength = Math.Max(maxBitNameLength, maxMemberNameLength);
foreach (var bitMask in deviceMetadata.BitMasks)
{
    var mask = bitMask.Value;
    foreach (var bitField in mask.Bits)
    {
        var fieldInfo = bitField.Value;
        var fieldName = FirmwareNamingConvention.Instance.Apply(bitField.Key);
        var fieldNamePadding = new string(' ', maxBitMemberNameLength - fieldName.Length + 6);
        var bitShift = (int)Math.Log(fieldInfo.Value, 2);
#>
#define B_<#= fieldName #><#= fieldNamePadding #>(1<<<#= bitShift #>)       // <#= fieldInfo.Description ?? string.Empty #>
<#
    }
}
#>
<#
foreach (var groupMask in deviceMetadata.GroupMasks)
{
    var mask = groupMask.Value;
    var maskSelect = TemplateHelper.GetMaskSelect(mask);
    var maskName = FirmwareGroupMaskNamingConvention.Instance.Apply(groupMask.Key);
    var maskNamePadding = new string(' ', maxBitMemberNameLength - maskName.Length);
#>
#define MSK_<#= maskName #>_SEL<#= maskNamePadding #>(<#= maskSelect #><<0)       // 
<#

    foreach (var member in mask.Values)
    {
        var memberInfo = member.Value;
        var memberName = FirmwareNamingConvention.Instance.Apply(member.Key);
        var memberNamePadding = new string(' ', maxBitMemberNameLength - memberName.Length - maskName.Length + 4);
#>
#define GM_<#= maskName #>_<#= memberName #><#= memberNamePadding #>(<#= memberInfo.Value #><<0)       // <#= memberInfo.Description ?? string.Empty #>
<#
    }
}
#>

#endif /* _APP_REGS_H_ */