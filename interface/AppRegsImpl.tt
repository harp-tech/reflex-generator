<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ parameter name="RegisterMetadataPath" type="string" #>
<#@ parameter name="IOMetadataPath" type="string" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Firmware.tt" #><##>
<#@ output extension=".c" #>
#include <avr/io.h>
#include "hwbp_core_types.h"
#include "app_ios_and_regs.h"

extern AppRegs app_regs;
<#
var deviceMetadata = TemplateHelper.ReadDeviceMetadata(RegisterMetadataPath);
var portPinMetadata = TemplateHelper.ReadPortPinMetadata(IOMetadataPath);
var inputPins = TemplateHelper.GetPortPinsOfType<InputPinInfo>(portPinMetadata).ToList();
var outputPins = TemplateHelper.GetPortPinsOfType<OutputPinInfo>(portPinMetadata).ToList();
var deviceRegisters = deviceMetadata.Registers;
var deviceName = deviceMetadata.Device;
int registerIndex;

int maxRegisterNameLength = 0;
int minRegisterAddress = byte.MaxValue;
int maxRegisterAddress = 32;
int totalRegisterSize = 0;
foreach (var registerMetadata in deviceRegisters)
{
    var register = registerMetadata.Value;
    var registerName = FirmwareNamingConvention.Instance.Apply(registerMetadata.Key);
    maxRegisterNameLength = Math.Max(maxRegisterNameLength, registerName.Length);
    minRegisterAddress = Math.Min(minRegisterAddress, register.Address);
    maxRegisterAddress = Math.Max(maxRegisterAddress, register.Address);
    totalRegisterSize += Math.Max(1, register.Length) * TemplateHelper.GetPayloadTypeSize(register.Type);
}
#>

/************************************************************************/
/* Configure and initialize IOs                                         */
/************************************************************************/
void init_ios(void)
{<#
var maxPinNameLength = Math.Max(
    inputPins.Count > 0 ? inputPins.Max(pin => FirmwareNamingConvention.Instance.Apply(pin.Key).Length) : 0,
    outputPins.Count > 0 ? outputPins.Max(pin => FirmwareNamingConvention.Instance.Apply(pin.Key).Length) : 0);
if (inputPins.Count > 0)
{
#>

    /* Configure input pins */
<#
    foreach (var pin in inputPins)
    {
        var pinInfo = pin.Value;
        var pinName = FirmwareNamingConvention.Instance.Apply(pin.Key);
        var pullMode = TemplateHelper.GetFirmwarePullMode(pinInfo.PinMode);
        var senseMode = TemplateHelper.GetFirmwareSenseMode(pinInfo.TriggerMode);
        var descriptionPadding = new string(' ', 49 - pinInfo.Port.Length - pullMode.Length - senseMode.Length);
#>
    io_pin2in(&<#= pinInfo.Port #>, <#= pinInfo.PinNumber #>, <#= pullMode #>, <#= senseMode #>);<#= descriptionPadding #>// <#= pinName #>
<#
    }

    var interruptPins = inputPins.Where(pin => pin.Value.InterruptPriority > 0).ToList();
    if (interruptPins.Count > 0)
    {
#>

    /* Configure input interrupts */
<#
        foreach (var pin in interruptPins)
        {
            var pinInfo = pin.Value;
            var port = pinInfo.Port;
            var pinNumber = pinInfo.PinNumber.ToString();
            var interruptNumber = pinInfo.InterruptNumber;
            var pinName = FirmwareNamingConvention.Instance.Apply(pin.Key);
            var interruptPriority = TemplateHelper.GetFirmwareInterruptPriority(pinInfo.InterruptPriority);
            var descriptionPadding = new string(' ', 36 - port.Length - interruptPriority.Length - pinNumber.Length);
#>
    io_set_int(&<#= port #>, <#= interruptPriority #>, <#= interruptNumber #>, (1<<<#= pinNumber #>), false);<#= descriptionPadding #>// <#= pinName #>
<#
        }
    }
}

if (outputPins.Count > 0)
{
#>

    /* Configure output pins */
<#
    foreach (var pin in outputPins)
    {
        var pinInfo = pin.Value;
        var pinName = FirmwareNamingConvention.Instance.Apply(pin.Key);
        var descriptionOffset = maxPinNameLength - pinName.Length + 10;
        var inputEnable = pinInfo.AllowRead ? "IN_EN_IO_EN" : "IN_EN_IO_DIS";
        var outMode = TemplateHelper.GetFirmwareOutputIO(pinInfo.PinMode);
        var descriptionPadding = new string(' ', 48 - pinInfo.Port.Length - outMode.Length - inputEnable.Length);
#>
    io_pin2out(&<#= pinInfo.Port #>, <#= pinInfo.PinNumber #>, <#= outMode #>, <#= inputEnable #>);<#= descriptionPadding #>// <#= pinName #>
<#
    }
#>

    /* Initialize output pins */
<#
}
    foreach (var pin in outputPins)
    {
        var pinName = FirmwareNamingConvention.Instance.Apply(pin.Key);
#>
    clr_<#= pinName #>;
<#
    }
#>
}

/************************************************************************/
/* Registers' stuff                                                     */
/************************************************************************/
AppRegs app_regs;

uint8_t app_regs_type[] = {
<#
registerIndex = 0;
foreach (var register in deviceRegisters.Values)
{
    var registerType = TemplateHelper.GetFirmwareRegisterType(register.Type);
#>
    TYPE_<#= registerType #><#= ++registerIndex < deviceRegisters.Count ? "," : string.Empty #>
<#
}
#>
};

uint16_t app_regs_n_elements[] = {
<#
registerIndex = 0;
foreach (var register in deviceRegisters.Values)
{
#>
    <#= register.Length == 0 ? 1 : register.Length #><#= ++registerIndex < deviceRegisters.Count ? "," : string.Empty #>
<#
}
#>
};

uint8_t *app_regs_pointer[] = {
<#
registerIndex = 0;
foreach (var registerMetadata in deviceRegisters)
{
    var registerName = FirmwareNamingConvention.Instance.Apply(registerMetadata.Key);
#>
    (uint8_t*)(&app_regs.REG_<#= registerName #>)<#= ++registerIndex < deviceRegisters.Count ? "," : string.Empty #>
<#
}
#>
};